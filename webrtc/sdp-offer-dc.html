<!doctype html>
<!--
This test uses data only, and thus does not require fake media devices.
-->

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>SDP generated by createOffer</title>
</head>
<body>
  <div id="log"></div>

  <!-- These files are in place when executing on W3C. -->
  <script src="/resources/testharness.js"></script>
  <script src="/resources/testharnessreport.js"></script>
  <script src="/common/vendor-prefix.js"
           data-prefixed-objects=
        '[{"ancestors":["window"], "name":"RTCPeerConnection"}]'></script>
  <script type="text/javascript">
  var test = async_test('The SDP generated by createOffer matches JSEP requirements for initial offer.');

  var gFirstConnection = null;

  // This function starts the test.
  test.step(function() {
    gFirstConnection = new RTCPeerConnection(null);

    gFirstConnection.createDataChannel('channel');

    gFirstConnection.createOffer()
      .then(test.step_func(function(offer) {
      assert_equals(offer.type, "offer");
      var sdp = offer.sdp;
      var sdp_lines = sdp.split("\r\n");
      assert_equals(sdp_lines[0], "v=0", "The first SDP line MUST be 'v=0'");
      var origin = sdp_lines[1];
      var origin_comp = origin.split(" ");
      assert_equals(origin_comp[0], "-", 'The value of the <username> field SHOULD be "-"');
      assert_equals(origin_comp[2], "0", 'The value of the <sess-version> field SHOULD be zero');
      assert_equals(sdp_lines[2], "s=-", 'The third SDP line MUST be a "s=" line.  a single dash SHOULD be used as the session name');
      var hasTLine = false;
      var m_sections = sdp.split(/m=/);
      var session_lines = m_sections[0].split("\r\n");
      for (var i = 0 ; i < session_lines.length ; i++) {
         // Start of a m= line, stop
         if (session_lines[i].match(/^m=/)) {
            break;
         }
         if (session_lines[i].match(/^[iuepbrz]=/)) {
            assert_unreached('Session Information ("i="), URI ("u="), Email Address ("e="), Phone Number ("p="), Bandwidth ("b="), Repeat Times ("r="), and Time Zones ("z=") lines are not useful in this context and SHOULD NOT be included.');
         }
         if (session_lines[i].match(/^k=/)) {
             assert_unreached('Encryption Keys ("k=") lines do not provide sufficient security and MUST NOT be included.');
         }
         if (session_lines[i] === 't=0 0') {
            hasTLine = true;
         }
      }
      assert_true(hasTLine, 'A "t=" line MUST be added; both <start-time> and <stop-time> SHOULD be set to zero');
      assert_equals(m_sections.length, 2, "One m= section per stream");
      var m_section_lines = m_sections[1].split("\r\n");
      assert_not_equals(m_section_lines[0].match(/^application 9 (UDP|TCP)\/DTLS\/SCTP/), null, 'The <media> field MUST be set to "application" and the <proto> field MUST be set to UDP/DTLS/SCTP or TCP/DTLS/SCTP');
      try {
        var mid = m_section_lines.filter(function(l) { return l.match(/^a=mid:/) !== null;})[0].split(':')[1];
      } catch (e) {
        assert_unreached('Could not parse mid from media description of data channel');
      }
      assert_equals(m_sections[0].split("\r\n").filter(function(l) {
           return l === "a=group:BUNDLE " + mid;
         }).length, 1,
                'a session-level "a=group" attribute MUST be added and MUST include the mid identifiers of each m= section');
      var sctp_port = m_section_lines[0].split(" ")[3];
      assert_equals(m_section_lines[1], "c=IN IP4 0.0.0.0", 'The m= line MUST be followed immediately by a "c=" line. the "c=" line must contain the "dummy" value "IN IP4 0.0.0.0"');
      var m_section_filters = [
         {"regex": /^a=mid:/, "req": 'the "a=mid" line must be included'},
         {"regex": /^a=ice-ufrag:/, "req": 'the "a=ice-ufrag" line must be included'},
         {"regex": /^a=ice-pwd:/, "req": 'the "a=ice-pwd" line must be included'},
         {"regex": /^a=ice-options:trickle$/, "req": 'the "a=ice-options" line must be included'},
         {"regex": /^a=fingerprint:/, "req": 'the "a=fingerprint" line must be included'},
         {"regex": /^a=setup:actpass$/, "req": 'the "a=setup" line must be included'},
         {"regex": new RegExp('^a=sctp-port:' + sctp_port + '$'), "req": 'the "a=sctp-port" referencing the SCTP port number line must be included'}
      ];
      m_section_filters.map(function(f) {
          var matchingLines = m_section_lines.filter(function(l) { return l.match(f.regex) !== null;});
          assert_equals(matchingLines.length, 1, f.req);
      });

      for (var i = 0 ; i < sdp_lines.length ; i++) {
          if (sdp_lines[i].match(/^a=crypto:/)) {
             assert_unreached('a=crypto MUST NOT be included');
          }
          if (sdp_lines[i].match(/^a=key-mgmt:/)) {
             assert_unreached('a=key-mgmt MUST NOT be included');
          }
          if (sdp_lines[i].match(/^a=ice-lite$/)) {
             assert_unreached('a=ice-lite MUST NOT be included');
          }
      }

      test.done();
    }))
    .catch(test.step_func(function(e) {
      assert_unreached('Error ' + e.name + ': ' + e.message);
    }));
  });
</script>

</body>
</html>
